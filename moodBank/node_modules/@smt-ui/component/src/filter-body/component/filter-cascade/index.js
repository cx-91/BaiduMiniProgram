/**
 * @file filter-single-list组件
 * @author zhangwen22(zhangwen22@baidu.com)
 */

/* global Component, swan*/
import {isIos} from '../../../common/utils/index';
import {COLOR_TIPS, COLOR_BLACK} from '../../../common/style/color';
Component({
    externalClasses: [ // eslint-disable-line
        'filter-cascade-class',
        'filter-cascade-column-class',
        'filter-cascade-column-item-class',
        'filter-cascade-column-item-text-class'
    ],
    properties: {
        // 筛选器ID
        options: {
            type: Array,
            value: []
        },
        // 筛选项对应的key
        optionKey: {
            type: String,
            value: 'text'
        },
        // 传入的value值
        value: {
            type: [String, Number, Array],
            value: ''
        },
        // 高亮时的文字和icon颜色
        activeColor: {
            type: String,
            value: COLOR_TIPS
        },
        // 默认状态的文字颜色
        fontColor: {
            type: String,
            value: COLOR_BLACK
        }
    },
    data: {
        // 是否ios
        isIos,
        // 选中的值
        currentValue: [],
        // 选中值对应的options
        currentOptions: [],
        // 上一次值
        lastValue: []
    },

    created() {
        this.init(this.data.value);
    },

    /**
     * 筛选面板点击事件
     *
     * @param {Object} event 点击对象
     */
    clkHdl(event) {
        const {index, idx, item} = event.currentTarget.dataset;
        this.handelClick(index, idx, item);
    },

    init(value, fillback) {
        if (!Array.isArray(value)) {
            value = this.initValue(value);
        }
        const normVal = JSON.stringify(value);
        const normCurrVal = JSON.stringify(this.data.currentValue);
        // 回填相同的值不触发
        if (fillback && normVal === normCurrVal) {
            return;
        }
        // 初始化选项
        const currentOptions = this.genOptions(value);
       // 如果没有匹配到value，并且有2列级以上数组，则初始化value数组，默认选择每列第一个
        if (value.length === 0 && currentOptions.length > 1) {
            value = Array.from({length: currentOptions.length - 1}, _ => 0);
        }
        this.setData({
            currentValue: value,
            lastValue: value,
            currentOptions
        });
        swan.nextTick(() => {
            const last = value.length - 1;
            const lastVal = value[last];
            this.handelClick(last, lastVal, currentOptions[last][lastVal], fillback);
        });
    },

    /**
     * 深度遍历，找到有children并且值和传入value相等的下标
     *
     * @param {Array} val 初始的value数组
     * @returns 处理之后的newValue
     */
    initValue(val) {
        let newValue = [];
        const dfs = (options, val) => options.some(({value, children}, idx) => {
            if (children && dfs(children, val)) {
                return newValue.push(idx);
            }
            return value === val && newValue.push(idx);
        });
        dfs(this.data.options, val, newValue);
        return newValue.reverse();
    },

    /**
     * 将传入的options转化为二维数组，每项为每列的数据
     *
     * @param {Array} value 内容值
     * @returns Array 转化后的数组
     */
    genOptions(value = []) {
        let i = 0;
        let newOptions = [];
        const dfs = (options, value) => {
            const items = options.map(({children, ...item}) => item);
            newOptions.push(items);
            const child = options[value[i] || 0] && options[value[i++] || 0].children;
            child && dfs(child, value);
            return newOptions;
        };
        return dfs(this.data.options, value, newOptions);
    },

    /**
     * 点击下拉筛选框面板内容
     *
     * @param {number} index 整个筛选器的第几项
     * @param {number} idx 级联中的第几列
     * @param {Object} item 渲染面板需要的数据
     * @param {Boolean} fillback 是否回填
     */
    handelClick(index, idx, item, fillback) {
        const segEqual = (current, last, start, end) =>
            new Array(end - start + 1).fill(0).every((item, index) => current[index] === last[index]);
        let {currentValue, lastValue, currentOptions} = this.data;
        currentValue.splice(index);
        currentValue.push(idx);
        // 级联选择的列数
        const cascadeColum = this.genOptions(currentValue).length - 1;
        // 完成级联选择（每一列都选择了）
        if (index === cascadeColum) {
            currentValue.splice(index, 1, idx);
            this.setData({
                lastValue: currentValue,
                currentOptions: this.genOptions(currentValue)
            });
            this.triggerEvent('change', {
                type: 'cascade',
                casCol: index,
                casRow: idx,
                casIndex: currentValue,
                casValue: currentOptions.map((e, i) => e[currentValue[i]]),
                fillback,
                ...item
            });
        }
        // 完成级联选择之后，下次再选择同样路径，用上一次值替换
        else if (segEqual(currentValue, lastValue, 0, index)) {
            currentValue.splice(0);
            currentValue.push(...lastValue);
            this.setData({
                currentOptions: this.genOptions(lastValue)
            });
        }
        // 还没有完成级联选择，剩余几列默认填充0
        else {
            let padLength = cascadeColum - currentValue.length;
            while (padLength--) {
                currentValue.push(0);
            }
        }
        this.setData({
            currentValue,
            currentOptions: this.genOptions(currentValue)
        });
    },

    /**
     * 数据回填
     *
     * @param {String} value 需要回填的数据
     */
    setValue(value) {
        this.init(value, true);
    }
});
